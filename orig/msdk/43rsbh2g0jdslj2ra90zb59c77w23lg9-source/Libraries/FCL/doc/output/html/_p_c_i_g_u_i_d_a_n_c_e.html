<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Deeptrust for PCI security architecture: Security Guidelines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="maxim-logo-202.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Deeptrust for PCI security architecture
   &#160;<span id="projectnumber">SPEC98T17 rev E</span>
   </div>
   <div id="projectbrief">Specification of Deeptrust, the Security Architecture for Cortex-M.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_p_c_i_g_u_i_d_a_n_c_e.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Security Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section explains how to maintain PCI PTS POI 5.0 compliance of the Deeptrust for PCI security architecture.</p>
<p>The Deeptrust for PCI security architecture has been pre-evaluated and the associated report is provided. In order to guarantee the preservation of the pre-evaluation results, the good practices exposed here must be applied.</p>
<p>Note: this document in only a set of guidelines that does not replace the applicable PCI PTS POI security Requirements.</p>
<h1><a class="anchor" id="sect_keymanag"></a>
Key Management</h1>
<p>Keys are needed for different purposes in the scope of PCI PTS.</p>
<h2><a class="anchor" id="sub_keys"></a>
Deeptrust for PCI's  keys</h2>
<p>The Deeptrust for PCI software uses the following keys:</p>
<table class="doxtable">
<tr>
<th>Key name/purpose </th><th>Key Algorithm/length </th><th>Public part location </th><th>Sec/Priv. part location </th><th>Integrity protection  </th></tr>
<tr>
<td>MRK / Maxim root key (CRK signing key) </td><td>ECDSA Secp256r1 w/ SHA256 </td><td>In MAX325xx ROM </td><td>In HSM at Maxim </td><td>Checked by CRC </td></tr>
<tr>
<td>CRK / Core firmware signing key </td><td>ECDSA Secp256r1 w/ SHA256 </td><td>In MAX325xx OTP Memory </td><td>In HSM </td><td>signature verified by MRK </td></tr>
<tr>
<td>Kfw / Box signing key w/ FW privilege </td><td>ECDSA Secp256r1 w/ SHA256 </td><td>In Core firmware </td><td>In HSM </td><td>signature verified by CRK </td></tr>
<tr>
<td>Ktrusted / Box signing key w/ TRUSTED privilege </td><td>ECDSA Secp256r1 w/ SHA256 </td><td>In Core firmware </td><td>In HSM </td><td>signature verified by CRK </td></tr>
<tr>
<td>Kother / Box signing key w/ OTHER privilege </td><td>ECDSA Secp256r1 w/ SHA256 </td><td>In Core firmware </td><td>In HSM </td><td>signature verified by CRK </td></tr>
<tr>
<td>DUKPT IPEK (example) </td><td></td><td>- </td><td></td><td>not verified, tamper response w/ processor package </td></tr>
<tr>
<td>DUKPT Current/Future keys (example </td><td></td><td>- </td><td></td><td>not verified, tamper response w/ processor package </td></tr>
</table>
<p>According to [REFXXXX], the MRK's public part is stored in the MAX325xx's ROM. The private counterpart is stored in a HSM controlled by Maxim. The purpose of the MRK is to allow loading a CRK previously signed. Maxim customers generate their CRK key pair and send the public part to Maxim. Maxim signs the CRK using the MRK stored in the HSM (signature operation is allowed to a restricted list of personnel). The signed CRK is returned to the customer who can install it into the MAX325xx. During installation, the CRK is transferred to the MAX325xx OTP memory after its signature has been verified by the MRK public key present in the ROM.</p>
<p>After this CRK loading operation, the customer can download a new firmware signed by the private part of the CRK. Upon boot the MAX325xx verifies this firmware signature using the public part of the CRK present in the MAX325xx OTP memory.</p>
<p>Once the core firmware is booted (if successfully verified by the CRK), it will check the signature of boxes using the appropriate Box signing public keys it contains (those keys are verified at the same time as the core firmware.</p>
<p>If all boxes signatures are correct, the software will execute normally.</p>
<h2><a class="anchor" id="sub_addkeys"></a>
Additional keys</h2>
<p>Additional keys may be added while enhancing and customizing the Deeptrust for PCI software.</p>
<ul>
<li>Asymmetric Signing/Encryption keys must be at least 2048-bit long for RSA or 256-bit long for EC based algorithms</li>
<li>Symmetric keys must be at least 128-bit long for AES or 256-bit long for EC based algorithms</li>
<li>Signing/Encryption keys stored out of the MAX325xx must be stored inside a Hardware Security Module (HSM). Access to the HSM must be gated by Smart Cards, protected by PIN codes. Vital keys must be protected by a sufficient quorum depending on the purpose of the key (e.g. firmware signing keys) The HSM should be stored in a safety deposit box when not used, and operated in a room with access control when in use.</li>
<li>It is the responsibility of the customer to handle additional keys according to the following PCI requirements:<ul>
<li>Generate your own private keys using certified products (hardware or software). Do not use the test keys provided in the SDK for deployment. Maxim Integrated provides PCI compliant tools for production.</li>
</ul>
</li>
</ul>
<p>Keep your private key really private, and have strict access control to that key.</p><ul>
<li>Export the public key into a “UCL” compliant format as exposed in this user manual.</li>
</ul>
<h2><a class="anchor" id="sub_keystor"></a>
Storing keys inside the MAX325xx</h2>
<p>The MAX325xx contains a battery-backed, tamper-reactive, non-volatile RAM (NVSRAM). This RAM is internal to the MAX325xx SoC, and its content is encrypted by a random symmetric key using AES.</p>
<p>Tamper detectors and battery presence are continuously monitored. If a tamper detector is triggered or the battery is removed or drained, the NVSRAM is instantly wiped.</p>
<p>Therefore it is strongly advised to store private or secret keys directly in the NVSRAM. If more space is needed for key storage, then store the above keys ENCRYPTED in another memory location, and keep the key encryption key in the NVSRAM.</p>
<h2><a class="anchor" id="sub_prov"></a>
Device Provisioning</h2>
<p>The Deeptrust for PCI software does not provide any platform provisioning service such as initial key loading or sensor activation. Such tasks should be performed during manufacturing. Maxim can provide detailed recommendations. The principle relies on the usage of the Secure Boot ROM's SCP protocol to download an authenticated temporary RAM application that performs the provisioning and sensor initialisation.</p>
<p>The Deeptrust for PCI software does not provide any key injection service.</p>
<p>The Deeptrust for PCI software does not provide any separate secure box update/loading in this release..</p>
<h1><a class="anchor" id="sect_fwdev"></a>
Software development</h1>
<p>Beyond the good practices applied by Maxim Integrated in the scope of the development of Deeptrust for PCI, the following recommendations apply to customers:</p>
<h2><a class="anchor" id="sub_fwlayout"></a>
Software layout</h2>
<p>The software is split in three major parts</p><ul>
<li>Secure boot ROM</li>
<li>The core firmware</li>
<li>Additional boxes</li>
</ul>
<p>The secure boot ROM is part of the MAX325xx SoC. It verifies the digital signature of the core firmware.</p>
<p>The core firmware contains the lightweight hypervisor, mbed-os (drivers and RTOS), startup code, C and C++ runtime libraries. It verifies the signatures of the additional boxes and prepares them for execution.</p>
<p>Additional boxes are:</p><ul>
<li>Secure Sandbox Services (a set of generic purpose secure services)</li>
<li>PCI security services (a set of services dedicated to PIN management)</li>
<li>An example demo (leveraging the two above boxes)</li>
</ul>
<p>Additional boxes are compiled and linked simultaneously to the core firmware. However, their location in flash memory is clearly separated from each other. As a result, the overall layout of software image is the following:</p>
<table class="doxtable">
<tr>
<th>Flash Address </th><th>Item  </th></tr>
<tr>
<td>bottom </td><td></td></tr>
<tr>
<td></td><td>Core FW header </td></tr>
<tr>
<td></td><td>Core FW image </td></tr>
<tr>
<td></td><td>Core FW signature </td></tr>
<tr>
<td></td><td></td></tr>
<tr>
<td></td><td>Box#1 header+signature </td></tr>
<tr>
<td></td><td>Box#1 configuration </td></tr>
<tr>
<td></td><td>Box#1 FW image </td></tr>
<tr>
<td></td><td></td></tr>
<tr>
<td></td><td>Box#2 header+signature </td></tr>
<tr>
<td></td><td>Box#2 configuration </td></tr>
<tr>
<td></td><td>Box#2 FW image </td></tr>
<tr>
<td></td><td>... </td></tr>
<tr>
<td></td><td>Box::n header+signature </td></tr>
<tr>
<td></td><td>Box::n configuration </td></tr>
<tr>
<td></td><td>Box::n FW image </td></tr>
<tr>
<td></td><td></td></tr>
<tr>
<td></td><td>Additional data storage </td></tr>
<tr>
<td>Top </td><td></td></tr>
<tr>
<td></td><td></td></tr>
</table>
<p>This layout is defined in the file ./mbed-os/target/TARGET_Maxim/common/max325xx.ld.inc. The Makefile defines the build process:</p><ul>
<li>compilation and link of the whole software</li>
<li>injection of the boxes signature verification keys into the core firmware</li>
<li>signature of the core firwmare using the CRK</li>
<li>signature of additional boxes using specific signing keys</li>
</ul>
<h2><a class="anchor" id="sub_newboxes"></a>
Adding new boxes</h2>
<p>In order to add a new box (every instance of box_NAME below must be replaced), the following rules apply:</p>
<ol type="1">
<li>create a new folder box_NAME in ./sources (or in a sub folder located under ./sources).</li>
<li>create a file sourcefile.cpp containing: <div class="fragment"><div class="line"><span class="preprocessor">  #include &quot;uvisor-lib/uvisor-lib.h&quot;</span></div><div class="line"><span class="preprocessor">  #include &quot;mbed.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">  #include &lt;errors.h&gt;</span></div><div class="line"><span class="preprocessor">  #include &lt;stdint.h&gt;</span></div><div class="line"><span class="preprocessor">  #include &lt;string.h&gt;</span></div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group__hypervisor.html#struct_uvisor_box_acl_item">UvisorBoxAclItem</a> my_acl[] = {</div><div class="line">   <span class="comment">//Put list of ACLs here</span></div><div class="line">  };</div><div class="line"></div><div class="line"><span class="preprocessor">#define BOX_NAME box_NAME</span></div><div class="line"></div><div class="line"><span class="comment">// Box Main Thread</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> box_appli_main(<span class="keyword">const</span> <span class="keywordtype">void</span> *);</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">  <span class="comment">// Declare globals going to the box&#39;s private heap here</span></div><div class="line">} box_context;</div><div class="line"></div><div class="line"><span class="comment">// Configure the  box.</span></div><div class="line"><a class="code" href="group__hypervisor.html#gafe52bfcc466d459d149c63966c2f4a58">UVISOR_BOX_NAMESPACE</a>(BOX_NAME);</div><div class="line">UVISOR_BOX_HEAPSIZE(0x1000);</div><div class="line">UVISOR_BOX_MAIN(box_appli_main, osPriorityNormal, 0x800);</div><div class="line"><a class="code" href="group__hypervisor.html#ga6143739a0475a71e8002f540de3c53f0">UVISOR_BOX_CONFIG</a>(BOX_NAME, my_acl, 1024, box_context, SIGNING_KEY_XXXXX);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> box_appli_main(<span class="keyword">const</span> <span class="keywordtype">void</span> *) {</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (1) {</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --></li>
<li>in the above, replace SIGNING_KEY_XXXXX by the appropriate signing key identifier (one of SIGNING_KEY_FW, SIGNING_KEY_TRUSTED, SIGNING_KEY_OTHER)</li>
<li>extend the file ./mbed-os/target/TARGET_Maxim/common/max325xx.ld.inc</li>
<li>below the marker "SECURE BOXES", add this set of definitions: <div class="fragment"><div class="line">.text.box_NAME_cfg :</div><div class="line"> {</div><div class="line">   *path/to/box_NAME*(.keep.addmodules*)</div><div class="line"> }&gt; FLASH_MOD</div><div class="line"> .text.box_NAME_code :</div><div class="line"> {</div><div class="line">   __start_box_NAME = .;</div><div class="line">   *path/to/box_NAME*(.text* .rodata*)</div><div class="line">   FILL(0xab)</div><div class="line">   . = ALIGN(4);</div><div class="line"> } &gt; FLASH_MOD</div><div class="line"> .data.box_NAME_datainit :</div><div class="line"> {</div><div class="line">     KEEP(*path/to/box_NAME*(.<a class="code" href="structdata.html">data</a>*))</div><div class="line">     FILL(0xab)</div><div class="line">     . = ALIGN(4);</div><div class="line"> } &gt; RAM  AT &gt; FLASH_MOD = 0xcc</div><div class="line"> __start_box_NAME_data_src  = LOADADDR(.<a class="code" href="structdata.html">data</a>.box_NAME_datainit);</div><div class="line"> __start_box_NAME_data_dest = ADDR(.<a class="code" href="structdata.html">data</a>.box_NAME_datainit);</div><div class="line"> __end_box_NAME             = LOADADDR(.<a class="code" href="structdata.html">data</a>.box_NAME_datainit)+SIZEOF(.<a class="code" href="structdata.html">data</a>.box_NAME_datainit);</div></div><!-- fragment --></li>
<li>Modify the top Makefile: in the target <code>%.elf.signed: %.elf Makefile</code>, add an additional line: <div class="fragment"><div class="line">$(call signmodule,box_NAME,$(SIGNINGKEY_XXX_PEM),$(TEMPDIR)${&lt;F}.temp)</div></div><!-- fragment --> Replace SIGNINGKEY_XXX_PEM by the appropriate file name that contains the private signing key.</li>
</ol>
<h2><a class="anchor" id="sub_fwsign"></a>
Firmware signature</h2>
<p>As explained above, different software parts have to be signed using different keys.</p>
<table class="doxtable">
<tr>
<th>Item </th><th>Signing key  </th></tr>
<tr>
<td>Core FW </td><td>CRK </td></tr>
<tr>
<td>Box#1 </td><td>Kfw/Ktrusted/Kother </td></tr>
<tr>
<td>Box#2 </td><td>Kfw/Ktrusted/Kother </td></tr>
<tr>
<td>... </td><td></td></tr>
<tr>
<td>Box::n </td><td>Kfw/Ktrusted/Kother </td></tr>
<tr>
<td></td><td></td></tr>
</table>
<p>The CRK protects the core firmware, which is firmware in the PCI terminology.</p>
<p>The boxes signature keys protect the boxes executable code and their configuration (ACLs). The signing key also define their privileges, via the implementation of the function "check_acl" which is part of the core firmware, and via the access control performed during RPC calls (See <a class="el" href="index.html#boxes">Code partitioning: Core firmware and Secure containers (aka "boxes")</a>).</p>
<p>Failure to verify any signature leads to a reset of the platform.</p>
<h2><a class="anchor" id="sub_fwmod"></a>
Software modularity</h2>
<p>In a further evolution, it will be possible to independently load/update boxes. To achieve this goal:</p><ul>
<li>boxes must use no global variables. Dynamic memory must be used instead. The lightweight hypervisor ensures that dynamically allocated memory is kept private to the box.</li>
<li>boxes must be built using position independent code so that they can be loaded at unknown addresses in memory</li>
<li>core firmware symbols must be available to allow linking boxes with the core</li>
<li>references between boxes (achieved via RPC)</li>
</ul>
<h2><a class="anchor" id="sub_boxrpc"></a>
Secure boxes code review</h2>
<p>Secure boxes must all be signed. Depending on the signing key, they will be granted various privileges. The Deeptrust for PCI architecture guarantees that the ACLs requested by the box cannot go beyond what is allowed by the use of the function check_acl, and also that boxes that provide RPC services can filter out calls based on the name and/or signing key of the caller.</p>
<p>Therefore, the signature key used for signing a box must be in accordance with the purpose of the box (least privilege principle). The check_acl function must not grant access to sensitive peripherals or memory area to boxes that do not need them.</p>
<p>Developer guidance on how to correctly configure and review Deeptrust implementations to ensure that they are correctly isolating non-security code:</p>
<p>Before using a signing key to approve a box for being added to the software or firmware, the developer must ensure that:</p><ul>
<li>the check_acl function correctly limits the ACLs of boxes</li>
<li>even if allowed by check_acl for the selected signing key,</li>
<li>the code must be manually reviewed and tested to make sure that:<ul>
<li>their sensitive data is kept in secure memory and not leaked in the public memory (use the private heap of the box)</li>
<li>the access control to their services offered via RPC is correctly implemented and tested</li>
<li>the ACLs of the box are restricted to what as strictly needed (minimum privilege, even if enforced by check_acl)</li>
<li>no bug may lead to leaking sensitive data</li>
<li>no bug may lead to a crash of the platform</li>
<li>the secure box does not monopolize the CPU resources</li>
</ul>
</li>
</ul>
<p>The use of static analysis is strongly recommended together with a manual code review.</p>
<p>The lightweight hypervisor provides some runtime checks of memory corruptions and overflows, in addition to GCC's stack protector feature used for the core firmware and additional boxes. This somehow mitigates the effect of bugs.</p>
<p>Mitigation of fuzzing is also implemented:</p><ul>
<li>A reset counter in NVSRAM is incremented at every platform reset</li>
<li>It is automatically erased after a while so that no more than 1 reset per 30sec period is allowed</li>
<li>If the reset occurs too frequently, a time penalty of 60 seconds is added</li>
</ul>
<h2><a class="anchor" id="sub_minconf"></a>
Minimal configuration</h2>
<p>The provided solution ensures the minimal software configuration through the use of GCC's options:</p><ul>
<li>-fdata-sections -ffunction-sections for compiling</li>
<li>-Wl,&ndash;gc-section for linking</li>
</ul>
<p>The above options eliminates dead code. Hence, by definition, only the strictly useful code is embedded in the final binary.</p>
<h2><a class="anchor" id="sub_crypto"></a>
Cryptographic services</h2>
<p>Encryption/decryption: The Deeptrust for PCI offers APIs [REFXXXX] that do not allow arbitrary encryption/decryption or signature. It uses 3DES for encryption of PIN.</p>
<p>Digital signature: It uses ECC digital signature for verification of integrity and authenticity of firmware and application images. It may use RSA/ECC digital signature for verification of smart card certificates (not included in this release).</p>
<p>Other services: An additional cryptographic library (UCL) is delivered and allows arbitrary cryptographic operations using any key (encryption / decryption, signature/verification, using AES, 3DES, ECDSA, RSA).</p>
<p>An additional key manager and wrapper above the UCL will provide strictly controlled cryptographic services isolated within a secure box.</p>
<h1><a class="anchor" id="sect_PIN"></a>
PIN and cardholder data management</h1>
<p>The provided Deeptrust for PCI uses DUKPT based PIN encryption only using ISO Format 0. The PIN is captured upon request using the PCI security services box that has exclusive access to display and keypad at that time. The PIN is read from keypad or touchscreen and stored in a buffer for 60s. From here, it can be encrypted w/ 3DES using DUKPT current key, or submitted to a smart card for verification.</p>
<p>PIN is erased from memory:</p><ul>
<li>if the 60s timer expires</li>
<li>if the platform is reset (whatever the reset source)</li>
<li>if the PIN is used (with DUKPT in <code>uvisor_ctx-&gt;resetcount</code> or submitted to card in <code>__pci_verify_offline_pin</code>)</li>
</ul>
<p>NOTE: AES for ISO format 4 PIN blocks will be supported in a further release</p>
<h1><a class="anchor" id="sect_Prompt"></a>
Prompt management</h1>
<p>In the current release, prompts are hard coded in the Secure Sandbox Services box, and RPC clients can request displaying prompts via an identifier.</p>
<p>Customers may relax this constraint using the new separate box signing feature:</p><ul>
<li>Boxes signed with Kfw are considered PCI firmware and can display arbitrary prompts</li>
<li>Other boxes can not display arbitrary prompts</li>
</ul>
<h1><a class="anchor" id="sect_SelfTest"></a>
Self Tests</h1>
<p>The Deeptrust for PCI provides an automatic 24-h reboot</p>
<h1><a class="anchor" id="sect_integ"></a>
Customer integration</h1>
<p>Adaptation of the Deeptrust for PCI to a new platform requires the following steps:</p>
<ul>
<li>Development of the Board Support Package within mbed-os/target:<ul>
<li>Adapt to the actual (touch)screen and pinpad</li>
<li>Adapt the board level power management (battery charging, PMIC, etc)</li>
</ul>
</li>
<li>Customization of the Deeptrust API services:<ul>
<li>Customize or adapt the APIs provided by the boxes Secure sandbox services PCI security services</li>
</ul>
</li>
<li>Adapt the data processing required for the target application: The default provided PCI security services box is able to perform EMV Level 2 PIN transaction with a smart card, and DUKPT based PIN encryption for online submission<ul>
<li>Add more PIN block formats</li>
<li>Implement remote communication link for online transactions</li>
</ul>
</li>
<li>Development of the client application(s) leveraging the PCI security services and secure sandbox services</li>
<li>Integration of other third party applications </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="site-footer" align="center">
<div id="site-footer-edge1"></div>
<!-- BEGIN: FOOTER CONTROL PANEL -->
<div id="fcp-shell">
<table id="fcp-table1" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr valign="middle">
    <td id="fcp-box1" align="left" width="97%">
    <div class="fcp-text"><nobr>© 2017 Maxim Integrated</nobr></div>
    </td>
    <td id="fcp-box2" align="right" width="1%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
    <td id="fcp-box3" align="right" width="1%">
    <div class="fcp-text"><nobr>
    <a class="fcp" href="http://www.maximintegrated.com/contact/">Contact Us</a>
    &nbsp;&nbsp; | &nbsp;&nbsp;
    <a class="fcp" href="http://www.maximintegrated.com/legal/privacy.cfm">Privacy Policy</a>
    &nbsp;&nbsp; | &nbsp;&nbsp;
    <a class="fcp" href="http://www.maximintegrated.com/legal/">Legal Notices</a>
    &nbsp;&nbsp; | &nbsp;&nbsp;
    </nobr></div>
    </td>
</tr>
</tbody></table>
</div><!-- /fcp-shell -->
<!-- END: FOOTER CONTROL PANEL -->
<div id="site-footer-edge2"></div>
</div>
